(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



AppendTo[$Path,ToFileName[{NotebookDirectory[]}]];
<<commons.m
<<algebraDirac.m


metricMink[sign_Integer/;sign==1||sign==-1][dim_]:=-sign DiagonalMatrix[Prepend[ConstantArray[1,dim-1],-1]]
metricMink::usage="metricMink[sign][dim], where sign can be 1 or -1, for mostly minus and mostly plus signature, respectively. ";

metric[sign_Integer/;sign==1||sign==-1||sign==0][vielb_List]:=Module[{dim,ans,\[Eta]},
dim=Length[vielb];
If[sign!=0,ans=Transpose[vielb].metricMink[sign][dim].vielb//FullSimplify,
ans=Transpose[vielb].vielb//FullSimplify
];
ans]
metric::usage="metric[sign][vielbeinMatrix], where sign can be: 1 -> (+, -, -, ...), -1 -> (-, +, +, ...), 0 -> Euclidean.";

induced[matrix_List,coord_List,inducedCoord_List,pullback_List]:=Module[
{pullbackRule=listsToRule[coord, pullback]},
Transpose[Grad[pullback,inducedCoord]].(matrix/.pullbackRule).Grad[pullback,inducedCoord]
]
induced::usage="induced[matrix, coord, inducedCoord, pullback] returns a the induced matrix.";

hodgeDual[component_,position_List, metric_List]:=Module[{dim,len,posHX,invMetric,ans},
dim=Length@metric;
len=Length@position;
posHX=Complement[Range[dim],position];
invMetric=Inverse@metric;

(* The combinatoric factor 1/(dim-len)! is not needed because we return a specific component. *)
ans=Times[Sqrt[Abs[Det@metric]],
Times@@(invMetric[[#,#]]&/@position),
Signature@Join[position,posHX](*this plays the Role of Levi-Civita symbol*),
component]/.Abs->Identity (*Abs has already removed the explicit minus*);
{ans,posHX}
]
hodgeDual::usage="hodgeDual[component, component's index as a list, metric] -> {hodge dual of the component, index as a list} 
Note the Levi-Civita tensor's convention is \!\(\*SubscriptBox[\(\[Epsilon]\), \(\(12 .. \) n\)]\) = 1. ";


christoffelS[X_?ListQ, G_?ListQ]:=Module[{dim,invMetric,array},
dim=Length@X;invMetric=Inverse[G];
array=ConstantArray[0,{dim,dim,dim}];
Table[
array[[\[Lambda],\[Mu],\[Nu]]]=Sum[1/2 invMetric[[\[Lambda],\[Rho]]](D[G[[\[Rho],\[Nu]]],X[[\[Mu]]]]+D[G[[\[Rho],\[Mu]]],X[[\[Nu]]]]-D[G[[\[Mu],\[Nu]]],X[[\[Rho]]]]),{\[Rho],1,dim}];
(* Use the symmetric property of \[Mu] and \[Nu] indices *)
array[[\[Lambda],\[Nu],\[Mu]]]=array[[\[Lambda],\[Mu],\[Nu]]],
{\[Lambda],1,dim},{\[Mu],1,dim},{\[Nu],\[Mu],dim}]//FullSimplify;
array
]
christoffelS::usage="christoffelS[coord, metric]. Notation Christoffel Symbols:\!\(\*FormBox[\(TraditionalForm\`\(\(\\\ \)\(\*SubscriptBox[SuperscriptBox[\(\[CapitalGamma]\), \(1\)], \(23\)] = \[CapitalGamma][\([1, 2, 3]\)]\)\)\),
TraditionalForm]\)";


spinConnection[X_?ListQ, G_?ListQ, ee_?ListQ]:=Module[{dim,iee, \[CapitalGamma]},
dim=Length@X;iee=Inverse[ee];
\[CapitalGamma]=christoffelS[X, G];
 (* ee[[a,\[Mu]]] \[Equal] \!\(
\*SubsuperscriptBox[\(E\), \(\[Mu]\), \(a\)]\ and\ inverse\ \(iee[\([\)\(\[Mu], a\)\(]\)]\)\) \[Equal] Subsuperscript[E, a, \[Mu]] *)
Table[
Sum[ee[[a,\[Nu]]]iee[[\[Lambda],b]]\[CapitalGamma][[\[Nu],\[Mu],\[Lambda]]],{\[Lambda],1,dim},{\[Nu],1,dim}]
-Sum[iee[[\[Lambda],b]]D[ee[[a,\[Lambda]]],X[[\[Mu]]]],{\[Lambda],1,dim}],{\[Mu],1,dim},
{a,1,dim},{b,1,dim}
]//FullSimplify
]
spinConnection::usage="spinConnection[coord, metric, vierbein]'s definition follows Sean Carroll's book (eq. J21). It uses christoffelS[] function.
Notation: \!\(\*FormBox[\(TraditionalForm\`\(\(\\\ \)\(\*SubsuperscriptBox[\(\[CapitalOmega]\), \(\[Mu]\\\ b\), \(a\)] = \[CapitalOmega][\([\[Mu], a, b]\)]\)\)\),
TraditionalForm]\). Note that for its lower indices version: \!\(\*SubscriptBox[\(\[CapitalOmega]\), \(\[Mu]\\\ a\\\ b\)]\) = -\!\(\*SubscriptBox[\(\[CapitalOmega]\), \(\[Mu]\\\ b\\\ a\)]\)";


riemannT[coord_List,metric_List]:=Module[{cs,dim,array},
dim=Length@coord;
cs=christoffelS[coord,metric];
array=ConstantArray[0,{dim,dim,dim,dim}];
Table[
array[[r,s,m,n]]=D[cs[[r,n,s]],coord[[m]]]-D[cs[[r,m,s]],coord[[n]]]+Sum[cs[[r,m,l]]cs[[l,n,s]]-cs[[r,n,l]]cs[[l,m,s]],{l,1,dim}];
(* use the antisymmetric property of m and n *)
array[[r,s,n,m]]=-array[[r,s,m,n]],
{r,1,dim},{s,1,dim},{m,1,dim},{n,m+1,dim} ];
array
]
riemannT::usage = "riemannT[coord, metric][[\[Rho],\[Sigma],\[Mu],\[Nu]]] = \!\(\*SubscriptBox[SuperscriptBox[\(R\), \(\[Rho]\)], \(\[Sigma]\\\ \[Mu]\\\ \[Nu]\)]\)";

ricciT[coord_List,metric_List]:=Module[{riemann,dim,array},
dim=Length@coord;
array=ConstantArray[0,{dim,dim}];
riemann=riemannT[coord,metric];
Table[
array[[m,n]]=Sum[riemann[[r,m,r,n]],{r,1,dim}];
(* use the symmetric property of m and n *)
array[[n,m]]=array[[m,n]],
{m,1,dim},{n,m,dim}];
array
]
ricciT::usage = "ricciT[coord, metric][[\[Mu],\[Nu]]] = \!\(\*SubscriptBox[\(R\), \(\(\\\ \)\(\[Mu]\\\ \[Nu]\)\)]\) = \!\(\*SubscriptBox[SuperscriptBox[\(R\), \(\[Rho]\)], \(\[Mu]\\\ \[Rho]\\\ \[Nu]\)]\)";

ricciScalar[coord_List,metric_List]:=Module[{invMetric},
invMetric=Inverse@metric;
Tr[invMetric.ricciT[coord,metric]]
]
ricciScalar::usage = "The trace of the Ricci tensor: \!\(\*SuperscriptBox[\(g\), \(\[Mu]\\\ \[Nu]\)]\) \!\(\*SubscriptBox[\(R\), \(\(\\\ \)\(\[Mu]\\\ \[Nu]\)\)]\)";



formSkeleton[name_][listOflists_List][i__]:=Module[{input,sorted,slist},
input={i}; (* input component *)
sorted=Sort@input;
slist=Sort/@listOflists;(* sort the list of non-vanishing components *)
If[
Or@@(Equal[sorted,#]&/@slist),
Signature[input]HoldForm@name@@sorted,
0
]
]
formSkeleton::usage="formSkeleton[name][{{1,2,3},{5,6,7}}][1,3,2] returns -HoldForm[name][1,2,3]. The non-specified components are 0. It incorporates the antisymmetry of the forms.";


basis[\[CapitalGamma]_][expr_]:=If[
ToString@Head@expr == ToString@\[CapitalGamma], 
{expr},
Cases[Apply[List,expr/.{Plus->List,Times->List}//Flatten],_\[CapitalGamma]]
]
basis::usage = "basis[\[CapitalGamma]][expr]. Example: expr = a + b \[CapitalGamma][1] + c \[CapitalGamma][1, 2] + ..., it will extract {\[CapitalGamma][1], \[CapitalGamma][1,2]}.
Use addUnitBasis[\[CapitalGamma]][expr] to add \[CapitalGamma][] to coefficient a. ";

sort[f_[]]:=1; (*f[] as a unit basis*)
sort[f_[x__]]:=Signature[{x}]f@@Sort[{x}]
sort[g__ f_[x__]]:=g Signature[{x}]f@@Sort[{x}]
sort::usage="It sorts the argument of a function and multiplies it the signature.";

basisSort[\[CapitalGamma]_][x_]:=Module[{base,rule,y,z},
y=Expand[x];
base=basis[\[CapitalGamma]][y];
rule=Table[base[[i]]->(sort/@base)[[i]],{i,1,Length@base}];
z=y/.rule;
Collect[z,basis[\[CapitalGamma]][z]]
]
basisSort::usage="basisSort[\[CapitalGamma]][expr] collects the expression according to its basis (i.e. function with the specified head). It uses sort[].";

baseCoefForm[\[CapitalGamma]_][expr_]:=Module[{new, base},
new=basisSort[\[CapitalGamma]][expr];
base=basis[\[CapitalGamma]][new];
listsToRule[
Prepend[base,Identity], 
Prepend[Coefficient[new,base],new/.\[CapitalGamma]-> zero]
]
]
baseCoefForm::usage="baseCoefForm[\[CapitalGamma]][expr], where expr contains \[CapitalGamma], will return: {basis1 -> coefficient1, ...}. If there's no unit basis, it will be named as Identity.";

addUnitBasis[\[CapitalGamma]_][x__]:=Module[{coefId},
coefId=x/.\[CapitalGamma]->zero;
coefId*\[CapitalGamma][]-coefId +x
]
addUnitBasis::usage="addUnitBasis[\[CapitalGamma]][expr] adds unity, which is represented by \[CapitalGamma][] to expr if it doesn't have it. This helps to treat all the terms of the expression at the same footing under, for example, NonCommutativeMultiply.";


poincarePatch[n_][x_,z_]:=Module[{coord,vierb},
coord={ToExpression@Table[ToString@x<> ToString[i],{i,1,n-1}],z}//Flatten;
vierb=DiagonalMatrix@Table[1/z,{i,1,n}];
{coord,vierb}
]
poincarePatch ::usage ="poincarePatch[dim][x, z] -> {coord, vielbeinMatrix}";

horosphericAdS[n_][x_,r_]:=Module[{coord,vierb},
coord={ToExpression@Table[ToString@x<> ToString[i],{i,1,n-1}],r}//Flatten;
vierb=DiagonalMatrix[Append[Table[E^r,{i,1,n-1}],1]];
{coord,vierb}
]
horosphericAdS ::usage ="horosphericAdS[dim][x, r] -> {coord, vielbeinMatrix}";


spherical[n_][\[Phi]_]:=Module[{coord,vierb},
coord=Table[ToExpression[ToString[\[Phi]]<>ToString[i]],{i,1,n}];

vierb=DiagonalMatrix@Table[
Product[Sin[ToExpression[ToString[\[Phi]]<>ToString[k]]],{k,1,i-1}],
{i,1,n}
];
{coord,vierb}
]
spherical ::usage ="spherical[dim][\[Phi]] -> {coord, vielbeinMatrix}, coord = {\[Phi]1,..., \[Phi]dim}";
volSph[n_]:=\[Pi]^(n/2)/Gamma[n/2+1]



