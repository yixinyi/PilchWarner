(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["geoMetric`"]

metricMink
metric
induced
hodgeDual

christoffelS
spinConnection
riemannT
ricciT
ricciScalar

poincarePatch
horosphericAdS

spherical
volSph
surfaceSph

Begin["`Private`"]
Needs["commons`"]


metricMink[sign_Integer/;sign==1||sign==-1][dim_]:=-sign DiagonalMatrix[Prepend[ConstantArray[1,dim-1],-1]]
metricMink::usage="metricMink[sign][dim], where sign can be 1 or -1, for mostly minus and mostly plus signature, respectively. ";

metric[sign_Integer/;sign==1||sign==-1||sign==0][vielb_List]:=Module[{dim,ans,\[Eta]},
dim=Length[vielb];
If[sign!=0,ans=Transpose[vielb].metricMink[sign][dim].vielb//FullSimplify,
ans=Transpose[vielb].vielb//FullSimplify
];
ans]
metric::usage="metric[sign][vielbeinMatrix], where sign can be: 1 -> (+, -, -, ...), -1 -> (-, +, +, ...), 0 -> Euclidean.";

induced[matrix_List,coord_List,inducedCoord_List,pullback_List]:=Module[
{pullbackRule=listsToRule[coord, pullback]},
Transpose[Grad[pullback,inducedCoord]].(matrix/.pullbackRule).Grad[pullback,inducedCoord]
]
induced::usage="induced[matrix, coord, inducedCoord, pullback] returns a the induced matrix.";

hodgeDual[component_,position_List, metric_List]:=Module[{dim,len,posHX,invMetric,ans},
dim=Length@metric;
len=Length@position;
posHX=Complement[Range[dim],position];
invMetric=Inverse@metric;

(* The combinatoric factor 1/(dim-len)! is not needed because we return a specific component. *)
ans=Times[Sqrt[Abs[Det@metric]],
Times@@(invMetric[[#,#]]&/@position),
Signature@Join[position,posHX](*this plays the Role of Levi-Civita symbol*),
component]/.Abs->Identity (*Abs has already removed the explicit minus*);
{ans,posHX}
]
hodgeDual::usage="hodgeDual[component, component's index as a list, metric] -> {hodge dual of the component, index as a list} 
Note the Levi-Civita tensor's convention is \!\(\*SubscriptBox[\(\[Epsilon]\), \(\(12 .. \) n\)]\) = 1. ";


christoffelS[X_?ListQ, G_?ListQ]:=Module[{dim,invMetric,array},
dim=Length@X;invMetric=Inverse[G];
array=ConstantArray[0,{dim,dim,dim}];
Table[
array[[\[Lambda],\[Mu],\[Nu]]]=Sum[1/2 invMetric[[\[Lambda],\[Rho]]](D[G[[\[Rho],\[Nu]]],X[[\[Mu]]]]+D[G[[\[Rho],\[Mu]]],X[[\[Nu]]]]-D[G[[\[Mu],\[Nu]]],X[[\[Rho]]]]),{\[Rho],1,dim}];
(* Use the symmetric property of \[Mu] and \[Nu] indices *)
array[[\[Lambda],\[Nu],\[Mu]]]=array[[\[Lambda],\[Mu],\[Nu]]],
{\[Lambda],1,dim},{\[Mu],1,dim},{\[Nu],\[Mu],dim}]//Simplify;
array
]
christoffelS::usage="christoffelS[coord, metric]. Notation Christoffel Symbols:\!\(\*FormBox[\(TraditionalForm\`\(\(\\\ \)\(\*SubscriptBox[SuperscriptBox[\(\[CapitalGamma]\), \(1\)], \(23\)] = \[CapitalGamma][\([1, 2, 3]\)]\)\)\),
TraditionalForm]\)";


spinConnection[X_?ListQ, G_?ListQ, ee_?ListQ]:=Module[{dim,iee, \[CapitalGamma]},
dim=Length@X;iee=Inverse[ee];
\[CapitalGamma]=christoffelS[X, G];
 (* ee[[a,\[Mu]]] \[Equal] \!\(
\*SubsuperscriptBox[\(E\), \(\[Mu]\), \(a\)]\ and\ inverse\ \(iee[\([\)\(\[Mu], a\)\(]\)]\)\) \[Equal] Subsuperscript[E, a, \[Mu]] *)
Table[
Sum[ee[[a,\[Nu]]]iee[[\[Lambda],b]]\[CapitalGamma][[\[Nu],\[Mu],\[Lambda]]],{\[Lambda],1,dim},{\[Nu],1,dim}]
-Sum[iee[[\[Lambda],b]]D[ee[[a,\[Lambda]]],X[[\[Mu]]]],{\[Lambda],1,dim}],{\[Mu],1,dim},
{a,1,dim},{b,1,dim}
]//Simplify
]
spinConnection::usage="spinConnection[coord, metric, vierbein][[mu, a, b]], with mu and b lower indices and a upper index. It uses christoffelS[coord, metric]. See Sean Carroll's book (eq. J21). Note that if we lower a, then it should be antisymmetric in a and b. ";


riemannT[coord_List,metric_List]:=Module[{cs,dim,array},
dim=Length@coord;
cs=christoffelS[coord,metric];
array=ConstantArray[0,{dim,dim,dim,dim}];
Table[
array[[r,s,m,n]]=D[cs[[r,n,s]],coord[[m]]]-D[cs[[r,m,s]],coord[[n]]]+Sum[cs[[r,m,l]]cs[[l,n,s]]-cs[[r,n,l]]cs[[l,m,s]],{l,1,dim}];
(* use the antisymmetric property of m and n *)
array[[r,s,n,m]]=-array[[r,s,m,n]],
{r,1,dim},{s,1,dim},{m,1,dim},{n,m+1,dim} ];
array
]
riemannT::usage = "riemannT[coord, metric][[\[Rho],\[Sigma],\[Mu],\[Nu]]] = \!\(\*SubscriptBox[SuperscriptBox[\(R\), \(\[Rho]\)], \(\[Sigma]\\\ \[Mu]\\\ \[Nu]\)]\)";

ricciT[coord_List,metric_List]:=Module[{riemann,dim,array},
dim=Length@coord;
array=ConstantArray[0,{dim,dim}];
riemann=riemannT[coord,metric];
Table[
array[[m,n]]=Sum[riemann[[r,m,r,n]],{r,1,dim}];
(* use the symmetric property of m and n *)
array[[n,m]]=array[[m,n]],
{m,1,dim},{n,m,dim}];
array
]
ricciT::usage = "ricciT[coord, metric][[\[Mu],\[Nu]]] = \!\(\*SubscriptBox[\(R\), \(\(\\\ \)\(\[Mu]\\\ \[Nu]\)\)]\) = \!\(\*SubscriptBox[SuperscriptBox[\(R\), \(\[Rho]\)], \(\[Mu]\\\ \[Rho]\\\ \[Nu]\)]\)";

ricciScalar[coord_List,metric_List]:=Module[{invMetric},
invMetric=Inverse@metric;
Tr[invMetric.ricciT[coord,metric]]
]
ricciScalar::usage = "ricciScalar[coord, metric] is the trace of the Ricci tensor: \!\(\*SuperscriptBox[\(g\), \(\[Mu]\\\ \[Nu]\)]\) \!\(\*SubscriptBox[\(R\), \(\(\\\ \)\(\[Mu]\\\ \[Nu]\)\)]\)";



poincarePatch[n_][x_,z_]:=Module[{coord,vierb},
coord={ToExpression@Table[ToString@x<> ToString[i],{i,1,n-1}],z}//Flatten;
vierb=DiagonalMatrix@Table[1/z,{i,1,n}];
{coord,vierb}
]
poincarePatch ::usage ="poincarePatch[dim][x, z] -> {coord, vielbeinMatrix}";

horosphericAdS[n_][x_,r_]:=Module[{coord,vierb},
coord={ToExpression@Table[ToString@x<> ToString[i],{i,1,n-1}],r}//Flatten;
vierb=DiagonalMatrix[Append[Table[E^r,{i,1,n-1}],1]];
{coord,vierb}
]
horosphericAdS ::usage ="horosphericAdS[dim][x, r] -> {coord, vielbeinMatrix}";


spherical[n_][\[Phi]_]:=Module[{coord,vierb},
coord=Table[ToExpression[ToString[\[Phi]]<>ToString[i]],{i,1,n}];

vierb=DiagonalMatrix@Table[
Product[Sin[ToExpression[ToString[\[Phi]]<>ToString[k]]],{k,1,i-1}],
{i,1,n}
];
{coord,vierb}
]
spherical ::usage ="spherical[dim][\[Phi]] -> {coord, vielbeinMatrix}, coord = {\[Phi]1,..., \[Phi]dim}";
volSph[n_]:=\[Pi]^(n/2)/Gamma[n/2+1]
volSph::usage="volSph[n]=\!\(\*FractionBox[SuperscriptBox[\(\[Pi]\), \(n/2\)], \(Gamma[n/2 + 1]\)]\), returns the volume of an n-ball.
volSph[n+1] = surfaceSph[n]/(n+1)";
surfaceSph[n_]:=(2\[Pi]^((n+1)/2))/Gamma[(n+1)/2]
surfaceSph::usage="surfaceSph[n]=\!\(\*FractionBox[\(2 \*SuperscriptBox[\(\[Pi]\), \(\((n + 1)\)/2\)]\), \(Gamma[\*FractionBox[\(n + 1\), \(2\)]]\)]\), returns the surface area of an n-sphere. 
surfaceSph[n+1] = 2\[Pi] volSph[n].";


End[]
EndPackage[]



